---
title: "Bayesian Sample Size Estimation for Multilevel Trials"
author: "Ulrich LÃ¶sener"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document: default
  pdf_document: default
---


```{r Packages, message=FALSE}
library(tidyr)       # pipes
library(dplyr)       # pipes
library(ggplot2)     # plots
library(lme4)        # fit multilevel model
library(mgcv)        # extracting vcov matrices
library(bain)        # Bayesian estimation
library(MASS)        # multinorm - already included in lme4?
library(latex2exp)   # latex notation in plots
```


SSD Function
```{r Function SSD}
SSD <- function(m=100, t.points=c(1,2,3,4,5), var.u0=0, var.u1=.1, var.e=.02, eff.size=.8, BFthres=3, eta=.8){
  
  source("fct_data_generation.R")
  start <- Sys.time()
  
  N <- 30            # initial N
  condition <- FALSE # condition initially false
  i <- 1             # iteration number
  
  medBF.H0 <- vector("list", 100)
  medBF.H1 <- vector("list", 100)
  medBFc.H0 <- vector("list", 100)
  medBFc.H1 <- vector("list", 100)
  medBFu.H0 <- vector("list", 100)
  medBFu.H1 <- vector("list", 100)
  prop.BF.H0 <- vector("list", 100)
  prop.BF.H1 <- vector("list", 100)

  
  while (condition==F) {
    
    N <- N+2
    results <- dat.gen.vec(m=m, N=N, t.points=t.points, var.u0=var.u0, var.u1=var.u1, var.e=var.e, eff.size=eff.size, BFthres=BFthres)
    
    medBF.H0[[i]] <- results$Median_BF0
    medBF.H1[[i]] <- results$Median_BF1
    prop.BF.H0[[i]] <- results$Prop_BF0
    prop.BF.H1[[i]] <- results$Prop_BF1
    medBFc.H0[[i]] <- results$Median_BF_c0
    medBFc.H1[[i]] <- results$Median_BF_c1
    medBFu.H0[[i]] <- results$Median_BF_u0
    medBFu.H1[[i]] <- results$Median_BF_u1
  
    # condition met?
    ifelse(prop.BF.H0[[i]]>eta & prop.BF.H1[[i]]>eta, condition <- TRUE, condition <- FALSE)
    print(list(N, prop.BF.H1[[i]]))
    i <- i+1
  }

  measures <- cbind(medBF.H0,medBF.H1, prop.BF.H0, prop.BF.H1, medBFc.H0, medBFc.H1, medBFu.H0, medBFu.H1)
  
  print(Sys.time() - start)
  
  return(measures[i-1,])

}
```

```{r eff size}

effsize <- rep(list(vector("list", 6)), 24)
eff <- rep(NA, 24)

for (i in 1:24) {
  effsize[i][[1]] <- dat.gen(N=100, eff.size = .2+(i/40))
  eff[i] <- .2+(i/40)
}

eff.medBF01.H0 <- rep(NA, 24)
eff.medBF10.H1 <- rep(NA, 24)
eff.propBF01.H0 <- rep(NA, 24)
eff.propBF10.H1 <- rep(NA, 24)
eff.meanBF01.H0 <- rep(NA, 24)
eff.meanBF10.H1 <- rep(NA, 24)

for(i in 1:24){
eff.medBF01.H0[i] <- effsize[[i]][1]
eff.medBF10.H1[i] <- effsize[[i]][2]
eff.propBF01.H0[i] <- effsize[[i]][3]
eff.propBF10.H1[i] <- effsize[[i]][4]
eff.meanBF01.H0[i] <- effsize[[i]][5]
eff.meanBF10.H1[i] <- effsize[[i]][6]
}


df.eff <- as.data.frame(cbind(as.numeric(eff.medBF10.H1), as.numeric(eff.propBF10.H1), as.numeric(eff.meanBF10.H1), eff))
colnames(df.eff) <- c("medBF10.H1", "propBF10.H1", "meanBF10.H1","eff.size")

mean_prop <- c(as.numeric(eff.meanBF10.H1), as.numeric(eff.propBF10.H1))
df.eff.long <- as.data.frame(cbind(mean_prop, rep(c(0,1), each=24), eff))
colnames(df.eff.long) <- c("mean_prop", "ind", "eff")


pdf(file = "C://Users/losen002/OneDrive - Universiteit Utrecht/Desktop/PhD/BayesianSSD/effsize.pdf", width = 6, height = 6)

ggplot(data=df.eff.long, aes(x=eff, y=mean_prop, group=factor(ind), color=factor(ind))) + geom_line(linewidth=1) +
scale_color_discrete(name="", labels=c("Mean log(BF)", "Power")) +
geom_hline(yintercept = 1, linetype="dashed") +
geom_hline(yintercept = 0, linetype="dashed") +
xlab("Effect Size") + ylab("") + 
theme_grey(base_size = 22) +
theme(legend.position = c(.2, .90))

dev.off()

```


```{r plots results}
b <- as.data.frame(measures2)

b$medBF01.H0 <- as.numeric(unlist(b$medBF01.H0))
b$medBF10.H1 <- as.numeric(unlist(b$medBF10.H1))
b$meanBF01.H0 <- as.numeric(unlist(b$mean.log.BF01.H0))
b$meanBF10.H1 <- as.numeric(unlist(b$mean.log.BF10.H1))
b$propBF01.H0 <- as.numeric(unlist(b$prop.BF01.H0))
b$propBF10.H1 <- as.numeric(unlist(b$prop.BF10.H1))

b$N <- seq(32, 74, 2)

# Plot Proportions of BF>3
pdf(file = "C://Users/losen002/OneDrive - Universiteit Utrecht/Desktop/PhD/BayesianSSD/prop.BF10.H1.pdf", width = 6, height = 6)
ggplot(data=b, aes(x=N, y=propBF10.H1)) + 
  geom_line(linewidth=1) +
  geom_hline(yintercept=.8, col="red", linetype="dashed") +
  labs(y="Proportion of BF01 larger than 3", x="N") + theme_grey(base_size = 22)
dev.off()

# Plot Median BF
pdf(file = "C://Users/losen002/OneDrive - Universiteit Utrecht/Desktop/PhD/BayesianSSD/meanBFs.pdf", width = 6, height = 6)
ggplot(data=b) + 
  geom_line(aes(x=N, y=meanBF01.H0, color="H0"), linewidth=1) +
  geom_line(aes(x=N, y=meanBF10.H1, color="H1"), linewidth=1) +
  labs(y="Mean log(BF)", x="N", color="Correct Hypothesis") + 
  theme_grey(base_size = 22) +
  theme(legend.position = c(.3, .90))
dev.off()


```


```{r measurement occasions}
meas.occ <- rep(list(vector("list", 6)), 8)
occ <- rep(NA, 8)

for(i in 1:8){
  meas.occ[i][[1]] <- dat.gen(m=10000, t.points = c(1:(i+2)))
  occ[i] <- (i+2)
}

occ.medBF01.H0 <- rep(NA, 8)
occ.medBF10.H1 <- rep(NA, 8)
occ.propBF01.H0 <- rep(NA, 8)
occ.propBF10.H1 <- rep(NA, 8)
occ.meanBF01.H0 <- rep(NA, 8)
occ.meanBF10.H1 <- rep(NA, 8)

for(i in 1:8){
occ.medBF01.H0[i] <- meas.occ[[i]][1]
occ.medBF10.H1[i] <- meas.occ[[i]][2]
occ.propBF01.H0[i] <- meas.occ[[i]][3]
occ.propBF10.H1[i] <- meas.occ[[i]][4]
occ.meanBF01.H0[i] <- meas.occ[[i]][5]
occ.meanBF10.H1[i] <- meas.occ[[i]][6]
}

d2 <- as.data.frame(cbind(as.numeric(occ.medBF01.H0), as.numeric(occ.medBF10.H1), as.numeric(occ.propBF01.H0), as.numeric(occ.propBF10.H1),as.numeric(occ.meanBF01.H0), as.numeric(occ.meanBF10.H1), occ))
colnames(d2) <- c("medBF01.H0", "medBF10.H1", "propBF01.H0","propBF10.H1","meanBF01.H0", "meanBF10.H1","occ")

pdf(file = "C://Users/losen002/OneDrive - Universiteit Utrecht/Desktop/PhD/BayesianSSD/medBF10.H1.pdf", width = 6, height = 6)

ggplot(data=d2) + geom_line(aes(y=unlist(propBF01.H0), x=occ), linewidth=1, color="red") +  geom_line(aes(y=unlist(propBF10.H1), x=occ), color="blue", linewidth=1) + xlab("occ") + ylab("") 

ggplot(data=d2) + geom_line(aes(y=unlist(medBF01.H0), x=occ), linewidth=1, color="red") +  geom_line(aes(y=unlist(medBF10.H1), x=occ), color="blue", linewidth=1) + xlab("occ") + ylab("") 


dev.off()

```


```{r Function ratios}

rat <- rep(list(vector("list", 5)), 11)
slop.var <- rep(NA, 11)

for(i in 1:11){
  rat[i][[1]] <- dat.gen(var.u1 = i/10, var.e = .1, m=10000)
  slop.var[i] <- i/10
}

rats <- slop.var/.1

rat.medBF01.H0 <- rep(NA, 11)
rat.medBF10.H1 <- rep(NA, 11)
rat.propBF01.H0 <- rep(NA, 11)
rat.propBF10.H1 <- rep(NA, 11)
rat.meanBF01.H0 <- rep(NA, 11)
rat.meanBF10.H1 <- rep(NA, 11)
  
  
for(i in 1:11){
rat.medBF01.H0[i] <- rat[[i]][1]
rat.medBF10.H1[i] <- rat[[i]][2]
rat.propBF01.H0[i] <- rat[[i]][3]
rat.propBF10.H1[i] <- rat[[i]][4]
rat.meanBF01.H0[i] <- rat[[i]][5]
rat.meanBF10.H1[i] <- rat[[i]][6]
}

d <- as.data.frame(cbind(as.numeric(rat.medBF01.H0), as.numeric(rat.medBF10.H1), as.numeric(rat.propBF01.H0), as.numeric(rat.propBF10.H1),as.numeric(rat.meanBF01.H0), as.numeric(rat.meanBF10.H1), rats))
colnames(d) <- c("medBF01.H0", "medBF10.H1", "propBF01.H0","propBF10.H1","meanBF01.H0", "meanBF10.H1","ratio")

pdf(file = "C://Users/losen002/OneDrive - Universiteit Utrecht/Desktop/PhD/BayesianSSD/medBF10.H1.pdf", width = 6, height = 6)

ggplot(data=d) + geom_line(aes(y=unlist(meanBF01.H0), x=ratio), linewidth=1) +  geom_line(aes(y=unlist(meanBF10.H1), x=ratio), linewidth=1) + xlab("ratio") + ylab("") 


dev.off()

```


```{r}
library(Rcpp)
cppFunction('NumericVector SSDc(int m, NumericVector tpoints, double var.u1, double var.e, double eff.size, double BFthres, double eta){
  int N = 30;
  double power = 0;
  Function dat.gen.cpp("dat.gen");
  
  while(power<.80){
    N = N+2;
    NumericVector results = dat.gen.cpp(m=m, N=N, t.points=t.points, ar.u0=var.u0, var.u1=var.u1, var.e=var.e, eff.size=eff.size, BFthres=BFthres);
    
    
  }
}')




```




Binary Algorithm
```{r Function SSD Binary}

SSD.binary <- function(m=100, t.points=c(1,2,3,4,5), var.u0=.0333, var.u1=.1, var.e=.0262, eff.size=.8, BFthres=3){
  source("fct_data_generation.R")
  
  start <- Sys.time()
  eta <- .8          # desired power
  N.current <- 30    # initial N
  N.min <- 20
  N.max <- 1000

  while (N.current!=N.min+1) {
    
    N.current <- round((N.min + N.max)/2, digits = 0)

    results <- dat.gen(m=m, N=N.current, t.points=t.points, var.u0=var.u0, var.u1=var.u1, var.e=var.e, eff.size=eff.size, BFthres=BFthres)
    # condition met?
    ifelse(results$Prop_BF0>eta & results$Prop_BF1>eta, condition <- TRUE, condition <- FALSE)
    ifelse(condition==FALSE, N.min <- N.current, N.max <- N.current)
    print(N.current)
    
  }
  print(Sys.time() - start) 

}

```
  


```{r}
df.prop.bf10.H1 <- as.data.frame(cbind(prop.bf10.H1[1:length(na.exclude(ss.seq))], na.exclude(ss.seq)))
colnames(df.prop.bf10.H1) <- c("prop.bf", "N")

# increase in proportion of BFs larger than BFthres
pdf(file = "C://Users/losen002/OneDrive - Universiteit Utrecht/Desktop/PhD/BayesianSSD/Prop.BF.medium.pdf", width = 6, height = 6)
ggplot(data=df.prop.bf10.H1, aes(x=N, y=prop.bf), linewidth=1.5) + 
  geom_line() +
  geom_hline(yintercept=eta, col="red", linetype="dashed") +
  labs(x="Proportion of BF01 larger than 3") 
dev.off()

# Sampling distribution of BFs for N
  
#bf10.H1.trim <- bf10.H1 #[bf10.H1<=quantile(bf10.H1, probs = .99)]
df.prop.bfs <- data.frame(c(bf10.H1, bf01.H0), rep(c("1","0"), each=m))
colnames(df.prop.bfs) <- c("BF", "hyp")
```

```{r}
# H0
pdf(file = "C://Users/losen002/OneDrive - Universiteit Utrecht/Desktop/PhD/BayesianSSD/Samp.dist.H0.pdf", width = 6, height = 6)

p0 <- ggplot() + geom_density(aes(x=unlist(BFs.H0)), linewidth=1) + 
  xlim(0, 50) + 
  labs(y="density", x="BF01") 

dpb0 <- ggplot_build(p0)

p0 + geom_area(data=data.frame(x=dpb0$data[[1]]$x[dpb0$data[[1]]$x>3], y=dpb0$data[[1]]$y[dpb0$data[[1]]$x>3]), aes(x=x, y=y), fill="grey") +
    annotate("text", x=c(2,10), y=c(.01,0.005), label=c(TeX("$BF_{thresh} = 3$"), TeX("$\\eta = .80$")), angle=c(90,0)) +
    geom_vline(xintercept=3, linetype=2, color="red", linewidth=1)

dev.off()

# H1
pdf(file = "C://Users/losen002/OneDrive - Universiteit Utrecht/Desktop/PhD/BayesianSSD/Samp.dist.H1.pdf", width = 6, height = 6)

p1 <- ggplot() + geom_density(aes(x=unlist(BFs.H1)), linewidth=1) + 
  xlim(0, 100) + 
  labs(y="density", x="BF10") 

dpb1 <- ggplot_build(p1)

p1 + geom_area(data=data.frame(x=dpb1$data[[1]]$x[dpb1$data[[1]]$x>3], y=dpb1$data[[1]]$y[dpb1$data[[1]]$x>3]), aes(x=x, y=y), fill="grey") +
    annotate("text", x=c(0,25), y=c(.01,0.0025), label=c(TeX("$BF_{thresh} = 3$"), TeX("$\\eta = .80$")), angle=c(90,0)) +
    geom_vline(xintercept=3, linetype=2, color="red", linewidth=1) 

dev.off()
```



# H0
bf01.H0.trim <- bf01.H0 #bf01.H0[bf01.H0<=quantile(bf01.H0, probs = .85)]
  
  plot(density(bf01.H0.trim), xlim=range(0:50))
  polygon(c(density(bf01.H0.trim)$x[density(bf01.H0.trim)$x >= 3 ], 3),
        c(density(bf01.H0.trim)$y[density(bf01.H0.trim)$x >= 3 ], 0),
        col = "slateblue1",
        border = 1)

p0 <- ggplot() + geom_density(aes(x=bf01.H0.trim), size=1) + 
  xlim(0, 50) + 
  geom_vline(xintercept=3, linetype=2, color="red") +
  annotate("text", x=2, y=.02, label="BFthresh=3", angle=90) +
  labs(title = TeX(r"(Sampling Distribution of $BF_{01}$ under $H_0$ for $N=20$)"), y="density", x=TeX("$BF_{01}$"))

dpb0 <- ggplot_build(p0)

p0 + geom_area(data=data.frame(x=dpb0$data[[1]]$x[dpb0$data[[1]]$x>3],
                       y=dpb0$data[[1]]$y[dpb0$data[[1]]$x>3]),
            aes(x=x, y=y), fill="grey")

```{r}

# both

pdf(file = "C://Users/losen002/OneDrive - Universiteit Utrecht/Desktop/PhD/BayesianSSD/SampDistH1.pdf", width = 6, height = 6)

p + geom_area(data=data.frame(x=dpb$data[[1]]$x[dpb$data[[1]]$x>3],
                       y=dpb$data[[1]]$y[dpb$data[[1]]$x>3]),
            aes(x=x, y=y), fill="grey")
dev.off()

pdf(file = "C://Users/losen002/OneDrive - Universiteit Utrecht/Desktop/PhD/BayesianSSD/SampDistH0.pdf", width = 6, height = 6)
p0 + geom_area(data=data.frame(x=dpb0$data[[1]]$x[dpb0$data[[1]]$x>3],
                       y=dpb0$data[[1]]$y[dpb0$data[[1]]$x>3]),
            aes(x=x, y=y), fill="grey")
dev.off()

# StatAreaUnderDensity <- ggproto(
#   "StatAreaUnderDensity", Stat,
#   required_aes = "x",
#   compute_group = function(data, scales, xlim = NULL, n = 50) {
#     fun <- approxfun(density(data$x))
#     StatFunction$compute_group(data, scales, fun = fun, xlim = xlim, n = n)
#   }
# )
# 
# stat_aud <- function(mapping = NULL, data = NULL, geom = "area",
#                     position = "identity", na.rm = FALSE, show.legend = NA, 
#                     inherit.aes = TRUE, n = 50, xlim=NULL,  
#                     ...) {
#   layer(
#     stat = StatAreaUnderDensity, data = data, mapping = mapping, geom = geom, 
#     position = position, show.legend = show.legend, inherit.aes = inherit.aes,
#     params = list(xlim = xlim, n = n, ...))
# }

```


```{r}
### SINGULARITY DIAGNOSTICS

marker <- rep(NA, m)
for(i in 1:m){
  marker[i] <- ifelse(isSingular(modelsH0[[1]][[i]]), 1, 0)
}

badmodels <- modelsH0[[1]][marker==1]
goodmodels <- modelsH0[[1]][marker==0]

badest <- rep(NA, length(badmodels))
badstderr <- rep(NA, length(badmodels))
for(i in 1:length(badmodels)){
badest[i] <- badmodels[[i]]@beta[3]
badstderr[i] <- diag(vcov(badmodels[[i]]))[3]
}

goodest <- rep(NA, length(goodmodels))
goodstderr <- rep(NA, length(goodmodels))
for(i in 1:length(goodmodels)){
goodest[i] <- goodmodels[[i]]@beta[3]
goodstderr[i] <- diag(vcov(goodmodels[[i]]))[3]
}

length(goodmodels)
length(badmodels)

summary(goodest)
summary(badest)
summary(goodstderr)
summary(badstderr)
```



```{r PDFs}

pdf(file = "C://Users/losen002/OneDrive - Universiteit Utrecht/Desktop/PhD/BayesianSSD/BF_PMP_H0.pdf",   
    width = 6, # The width of the plot in inches
    height = 6) # The height of the plot in inches

  par(mfrow=c(2,4))
  plot(x=ss.seq, y=medbf10.H0[1:length(ss.seq)], type="l", xlab="N", ylab="median BF10 under H0")
  plot(x=ss.seq, y=medbf01.H0[1:length(ss.seq)], type="l", xlab="N", ylab="median BF01 under H0")
  plot(x=ss.seq, y=medbf.1u.H0[1:length(ss.seq)], type="l", xlab="N", ylab="median BF unconstr. under H0")
  plot(x=ss.seq, y=medbf.1c.H0[1:length(ss.seq)], type="l", xlab="N", ylab="median BF complement under H0")
  
  plot(x=ss.seq, y=medpmp.a1.H0[1:length(ss.seq)], type="l", xlab="N", ylab="median PMPa under H0")
  plot(x=ss.seq, y=medpmp.b1.H0[1:length(ss.seq)], type="l", xlab="N", ylab="median PMPb under H0")
  plot(x=ss.seq, y=medpmp.c1.H0[1:length(ss.seq)], type="l", xlab="N", ylab="median PMPc under H0")
  plot(x=ss.seq, y=prop.bf01.H0[1:length(ss.seq)], type="l", xlab="N", ylab="proportion of BFs larger 3 under H0")
  abline(h=.8, col="red")

dev.off()


pdf(file = "C://Users/losen002/OneDrive - Universiteit Utrecht/Desktop/PhD/BayesianSSD/BF_PMP_H1_medium.pdf",   
    width = 6, # The width of the plot in inches
    height = 6) # The height of the plot in inches

  par(mfrow=c(2,4))
  plot(x=ss.seq, y=medbf10.H1[1:length(ss.seq)], type="l", xlab="N", ylab="median BF10 under H1")
  plot(x=ss.seq, y=medbf01.H1[1:length(ss.seq)], type="l", xlab="N", ylab="median BF01 under H1")
  plot(x=ss.seq, y=medbf.1u.H1[1:length(ss.seq)], type="l", xlab="N", ylab="median BF unconstr. under H1")
  plot(x=ss.seq, y=medbf.1c.H1[1:length(ss.seq)], type="l", xlab="N", ylab="median BF complement under H1")
  
  plot(x=ss.seq, y=medpmp.a1.H1[1:length(ss.seq)], type="l", xlab="N", ylab="median PMPa under H1")
  plot(x=ss.seq, y=medpmp.b1.H1[1:length(ss.seq)], type="l", xlab="N", ylab="median PMPb under H1")
  plot(x=ss.seq, y=medpmp.c1.H1[1:length(ss.seq)], type="l", xlab="N", ylab="median PMPc under H1")
  plot(x=ss.seq, y=prop.bf10.H1[1:length(ss.seq)], type="l", xlab="N", ylab="proportion of BFs larger 3 under H1")
  abline(h=eff.size, col="red")

dev.off()

```


The resulting Bayes Factors tell us that $H_1$ is the hypothesis most likely to be true out of the set of considered hypotheses. We therefore conclude that in the treatment group ($X_1$), the symptom level increases more over time compared to the control group ($X_0$).

## Descriptives/plots

```{r Descriptives, echo=F}
# plot individual trajectories
ggplot(data = dat, aes(x = t, y = y, group = id, color = as.factor(treat))) + geom_line()

boxplot(formula = y ~ treat, data = dat) # in a boxplot
```

As can be seen from the figure, individuals differ in their intercept and slope. Subjects in the treatment group ($X_1$) seem to have systematically higher slopes as compared to those in the control group ($X_0$), suggesting an interaction effect between time and treatment. Also, the variability of y scores seems to increase over time, rendering the assumption of compound symmetry untenable. 


```{r Plots, echo=F}
# one line for everyone
ggplot(data = dat, aes(x = t, y = y), color = treat) + 
  geom_jitter(aes(color = treat), width = .1, height = 0) + 
  geom_smooth(method = "lm", formula = 'y ~ x')
# base
p <- ggplot(data = dat, aes(x = t, y = y, group = id, color = treat)) + geom_jitter(width = .1, height = 0)
# different lines for treat
p  + geom_smooth(group = 0, method = "lm", data = subset(dat, dat$treat == 0), formula = 'y ~ x') + geom_smooth(group = 0, method = "lm", data = subset(dat, dat$treat == 1), formula = 'y ~ x')

```

## Intercept only model

```{r Intercept only}
int.only <- lmer(y ~ 1 + (1 | id), data = dat)
summary(int.only) 
logLik(int.only)           
performance::icc(int.only) 
p + geom_smooth(method = "lm", formula = y ~ 1, se = F)
```

--------------------------------------------------------------------------------

## Appendix: In-between models

### Level 1 predictor: time

```{r Lvl 1}
lvl1 <- lmer(y ~ time + (1 | id), data = dat)
summary(lvl1)
logLik(lvl1)           
anova(int.only, lvl1)  
performance::icc(lvl1) 
```


### Level 2 predictor: treat

```{r Lvl 2}
lvl2 <- lmer(y ~ time + treat + (1 | id), data = dat)
summary(lvl2)
logLik(lvl2)           # -1063.76 (df=5) - better fit compared to lvl1 predictor only
anova(lvl1, lvl2)      # likelihood ratio test significant
performance::icc(lvl2) # 0.044
vcov.lmerMod(lvl2)
```

### Random slope for time

```{r Random slope}
rand.slop <- lmer(y ~ time + treat + (1 + time | id), data = dat)
summary(rand.slop)
logLik(rand.slop) 
anova(lvl2, rand.slop)
performance::icc(rand.slop)
```
